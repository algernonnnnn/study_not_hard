# 指针
指针是用于存储和操作变量的内存地址的特殊变量，实现高效的数据访问和管理。我们常提到的指针一般都指的是普通变量或对象的指针，不包括指向类或结构体成员的指针。
## 指针声明
指针声明可以用指针声明符`*`来声明,指针指向谁*指针就是谁。

声明 `S* D;`将 `D`声明为指向由声明说明符序列`S`确定的类型的指针。
指向成员的指针声明符：声明`S C::* D;`将`D`声明为指向由声明说明符序列`S`确定的类型的`C`的非静态成员的指针。

没有指向引用的指针，因为引用实质上是某个变量的别名，并没有独立的内存地址，所以无法用指针指向引用，没有指向位域的指针，因为位域通常不是独立的内存单元，多个位域可能共享同一个字节或者多个字节，无法获得单独的地址。
## 类型匹配
在C++中，指针的类型必须与它所指向的对象类型一致，这样才能安全地访问和操作对象的数据。
示例：
```cpp
int a = 5;
int* p = &a;        //类型匹配，p是 int*，指向int
double b = 3.14;
double * dp = &b;   //类型匹配，dp是 double*，指向double\

int * p = &b;       //类型不匹配
char* p3 = (char*)&a; // 类型不匹配，但可以强制转换（可能导致未定义行为）
```
C++支持类型转化，但是需要谨慎使用，避免类型不匹配带来的风险。

### 对象指针
对象指针是指向对象的指针变量。在C++中，对象指针用于访问和操作类的实例。通过对象之中呢可以调用对象的成员函数和访问成员变量。
示例：
``` cpp
class Person{
    int age;
    void showAge(){
        std::cout << age << std::endl;
    }
};

int main(){
    Person P;
    p.age = 20;
    Person* p = &p;         //对象指针，指向p
    ptr->showAge();         //通过指针调用成员函数
    ptr->age = 25;          //通过指针访问成员变量
}
```
- `->`是内置成员访问运算符，通过对象或结构体指针访问对象或结构体中的成员变量或成员函数。
- `.`也是内置成员访问运算符，用于对象或结构体变量直接访问成员变量或成员函数。

### void指针
`void`指针是一种特殊的指针类型，可以指向任何类型的数据，但是不能直接解引用访问数据内容，需强制类型转换为具体类型指针。
示例：
```cpp
int a = 10;
void* p;
p = &a;         //指向int
```

如果要把`void*`指针转换为原来的指针类型，必须使用`static_cast`或强制类型转换，这样才能恢复原始指针类型和正确访问数据。
示例：
```cpp
int a = 10;
int* p1= &a;
void*vp = p1;           //隐式转换，vp现在指向a
int* pa = static_cast<int*>(vp);    //显示转换回int*，指针值不变
```

`void`指针与`char`指针有相同的大小、表示形式和对齐方式
`void`指针常用于需要传递任意类型数据的场景，比如C语言的库函数接口
- `std::malloc`返回`void*`，因为它是不知道你要分配什么类型的数据，需要你自己转换成合适的类型指针。
- `std::qsort`的回调函数参数是`const void*`，这样可以比较任意类型的数据，用户要在回调里把它转换成实际类型再处理。
- `pthread_create `的线程函数参数和返回值都是 void*，这样可以传递和返回任意类型的数据，用户要自己转换类型。

