# 指针
指针是用于存储和操作变量的内存地址的特殊变量，实现高效的数据访问和管理。我们常提到的指针一般都指的是普通变量或对象的指针，不包括指向类或结构体成员的指针。
## 指针声明
指针声明可以用指针声明符`*`来声明,指针指向谁*指针就是谁。

声明 `S* D;`将 `D`声明为指向由声明说明符序列`S`确定的类型的指针。
指向成员的指针声明符：声明`S C::* D;`将`D`声明为指向由声明说明符序列`S`确定的类型的`C`的非静态成员的指针。

没有指向引用的指针，因为引用实质上是某个变量的别名，并没有独立的内存地址，所以无法用指针指向引用，没有指向位域的指针，因为位域通常不是独立的内存单元，多个位域可能共享同一个字节或者多个字节，无法获得单独的地址。
## 类型匹配
在C++中，指针的类型必须与它所指向的对象类型一致，这样才能安全地访问和操作对象的数据。
示例：
```cpp
int a = 5;
int* p = &a;        //类型匹配，p是 int*，指向int
double b = 3.14;
double * dp = &b;   //类型匹配，dp是 double*，指向double\

int * p = &b;       //类型不匹配
char* p3 = (char*)&a; // 类型不匹配，但可以强制转换（可能导致未定义行为）
```
C++支持类型转化，但是需要谨慎使用，避免类型不匹配带来的风险。

## 对象指针
对象指针是指向对象的指针变量。在C++中，对象指针用于访问和操作类的实例。通过对象之中呢可以调用对象的成员函数和访问成员变量。
示例：
``` cpp
class Person{
    int age;
    void showAge(){
        std::cout << age << std::endl;
    }
};

int main(){
    Person P;
    p.age = 20;
    Person* p = &p;         //对象指针，指向p
    ptr->showAge();         //通过指针调用成员函数
    ptr->age = 25;          //通过指针访问成员变量
}
```
- `->`是内置成员访问运算符，通过对象或结构体指针访问对象或结构体中的成员变量或成员函数。
- `.`也是内置成员访问运算符，用于对象或结构体变量直接访问成员变量或成员函数。

## 万能指针
万能指针通常指`void`指针是一种特殊的指针类型，可以指向任何类型的数据，但是不能直接解引用访问数据内容，需强制类型转换为具体类型指针。
示例：
```cpp
int a = 10;
void* p;
p = &a;         //指向int
```

如果要把`void*`指针转换为原来的指针类型，必须使用`static_cast`或强制类型转换，这样才能恢复原始指针类型和正确访问数据。
示例：
```cpp
int a = 10;
int* p1= &a;
void*vp = p1;           //隐式转换，vp现在指向a
int* pa = static_cast<int*>(vp);    //显示转换回int*，指针值不变
```

`void`指针与`char`指针有相同的大小、表示形式和对齐方式
`void`指针常用于需要传递任意类型数据的场景，比如C语言的库函数接口
- `std::malloc`返回`void*`，因为它是不知道你要分配什么类型的数据，需要你自己转换成合适的类型指针。
- `std::qsort`的回调函数参数是`const void*`，这样可以比较任意类型的数据，用户要在回调里把它转换成实际类型再处理。
- `pthread_create `的线程函数参数和返回值都是 void*，这样可以传递和返回任意类型的数据，用户要自己转换类型。

## 函数指针和指针函数
我们在遇到这类问题是可以将其理解为函数的指针和指针的函数。
### 函数指针
顾名思义，函数指针就是函数的指针，本质上是一个指针，是一个指向函数的指针变量，可以用来调整函数或者作为参数传递。
定义格式：
``` cpp
int (*funcPtr)(int, int); //指向参数为两个int，返回int的函数的指针
```
示例：
``` cpp
int add(int x, int y){
    return x + y;
}
int (*p)(int, int) = add'//p指向add函数
int resule = p(2,3);
```
函数指针可以用于保存和调用函数地址，实现回调机制、动态选择函数、作为参数传递函数等。这样可以让程序在运行时决定调用哪个函数，提高代码的灵活性和可扩展性。
 
### 指针函数
同样的，指针函数就是指针的函数，是返回值为指针的函数。
定义格式：
```cpp
int* func();    //返回int类型指针的函数 
```
指针函数用于返回指针类型的数据，这样可以让函数返回动态分配的内存、数组、对象等，实现灵活的数据管理。例如返回一个数组的首地址或动态分配的对象指针。
示例：
```cpp
int* createInt(int value){
    int* p = new int(value);
    return p;
}

int main(){
    int* ptr = createInt(43);
    std::cout << *ptr << std::endl;
    delete ptr;
    return 0;
}
```
## 空指针
每个类型的指针中都有一个特殊值，称为该类型的空指针。它的值为`NULL`，它不指向对象或者函数，不能被解引用。空指针常量用于表示"指针不指向任何有效对象"，即指针为空。可以用来初始化指针或给指针赋值。 
我们可以用`0`给指针赋值，例如`int* p = 0;`表示`p`是空指针，或者在C++11开始，可以用`nullptr`赋值，例如`int* p = nullptr;`,更安全、语义更加明确。

## const与指针
比较简单的记法就是当`const`在`*`左边，修饰的是对象内容，`const`在`*`右边修饰的是指针本身，两边都有的情况下指针和内容都不可变。
# 引用
C++引用是一种为变量起别名的机制，最经典的例子就是周树人的艺名叫鲁迅，鲁迅和周树人是一个吗？答案是肯定的。

语法上用`&`声明。引用必须初始化，之后始终绑定到同一个对象。通过引用操作变量时，实际就是操作原对象。
## 注意事项
### 1. 引用必须初始化
因为引用本质上是某个变量的别名，必须在定义时就明确指向哪个对象，且初始化时不能指向空值。
### 2. 不可重新绑定
引用一旦绑定对象，不能再指向其他值
### 3. 避免绑定临时变量或局部变量
如果引用绑定到临时或已销毁的对象，会导致未定义行为。

## 将引用作为函数参数
传递引用和传递指针都能让函数直接操作原始数据，提高效率，避免数据副本。但引用语法更简洁，使用更安全，代码可读性更好，不需要显式取地址和解引用操作。对于大数据或对象参数，引用传递比值传递更高效、更节省空间。

## 左值引用右值引用
### 左值和右值
可以取地址的对象就是左值，位于等号左边，不可以取地址的对象就是右值，位于等号右边。
`int a = 6;`中`a`就是左值，`6`是右值
### 左值引用
左值引用就是对左值的引用，给左值取别名。

通常左值引用无法指向右值，但是const左值可以指向右值，const引用不会修改指向值
### 右值引用
右值引用是C++引入的一种新的引用类型，语法为`T&&`它可以绑定到右值，用于支持移动语义和完美转发。

因为右值没有名字，所以我们只能通过引用的方式找到它。通过右值引用，延长了该对象的生命周期，只要这个右值引用活着，这个右值临时变量就会活着。

那么右值引用可以引用左值吗？

当然可以，`std::move()`，但是它本质上只是能把左值强制转化为右值，不会有性能提升
#### 右值引用的应用场景
##### 1. 实现移动语义
- 移动语义是C++11引入的一种机制，允许对象的资源从一个对象移动到另一个对象，而不是进行拷贝，这样可以大幅度提升性能。
- 移动之后，原对象通常处于“空”或“可析构”状态，但不会再拥有原资源。
- 
示例：
```cpp
#include <iostream>
#include <utility>

class MyData{
public:
    int* data;
    MyData(int value) : data(new int(value)){
        std::cout << "构造" << std::endl;
    }
    //移动构造
    MyData(MyData&& other) noexcept : data(other.data){
        other.data = nullptr;
        std::cout << "移动构造" << std::endl;
    }
    //析构函数
     ~MyData() {
        delete data;
        std::cout << "析构\n";
    }
};

int main() {
    MyData a(10);
    MyData b = std::move(a); // 触发移动构造
    return 0;
}
```
##### 2. 实现完美转发
完美转发是指在模板函数中，能够将参数的“左值”或“右值”属性完整地传递给另一个函数。实现时，通常用万能引用（T&&）接收参数，并用 std::forward<T>(arg) 转发，这样被调用的函数能准确区分参数是左值还是右值，避免不必要的拷贝或类型变化。完美转发常用于工厂函数、包装函数等泛型编程场景。

示例：
```c++
#include <iostream>
#include <utility>

void print(int& x) {
    std::cout << "左值引用: " << x << std::endl;
}

void print(int&& x) {
    std::cout << "右值引用: " << x << std::endl;
}

template<typename T>
void wrapper(T&& arg) {
    print(std::forward<T>(arg)); // 完美转发
}

int main() {
    int a = 10;
    wrapper(a);        // 输出：左值引用: 10
    wrapper(20);       // 输出：右值引用: 20
    return 0;
}
```
### const与引用
常引用（const 引用）是指用 const 修饰的引用，语法为 const T&。它表示通过该引用不能修改所绑定对象的值。

特点与作用：

可以绑定到常量、临时对象、右值或左值。
保护被引用对象不被修改，提高安全性。
常用于函数参数，避免拷贝，提高效率，同时保证只读。
示例：
```c++
void printValue(const int& x) {
    // x 不能被修改
    std::cout << x << std::endl;
}

int a = 10;
printValue(a);    // 传左值
printValue(20);   // 传右值或常量
```

# 指针和引用的区别
- 指针是一个变量，它存储的内容为一个地址；引用只是给一个已有对象起别名
- 指针第一个实体，需要分配内存空间；引用只是变量起别名，不需要分配内存空间
- 指针可以有多级指针，别能有多级引用
- 自增运算不一样
- 指针可以不用初始化，引用必须初始化