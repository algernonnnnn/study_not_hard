# C与C++
**C语言**是面向过程的程序设计，主要核心为：数据结构和算法，具有高效的特性，对于C语言程序的设计，主要是考虑如何通过一个过程，对输入进行处理得出一个输出。**C++**是面向对象的程序设计，对于C++，首先考虑的是如何构造一个对象模型，让这个模型配合对应问题，这样可以通过获取对象状态信息得到输出。

## C与C++的区别
C++畅销书作者侯捷说过当我们谈论C++的时候，其实在谈论四个方面的东西
- 面向过程的编程语言
- 面向对象的编程语言
- STL
- 元编程

其中只有面向过程的编程语言与C语言的定位重合，所以如果面试官问到C语言和C++的区别是什么的时候，我们就可以回答：
```
C语言是面向过程的编程语言，而C++不仅是面向过程的编程语言，还是面向对象的编程语言，同时包含了C中没有的STL，而且C++支持函数式编程\泛型编程\元编程。
C++号称是C语言的超集，但是还有一些细小的点是C++不能兼容C语言的。例如空结构体在C语言中大小是0，在C++中是1；C语言中main函数的返回值可以是任何类型，C++中main函数的返回值只能是int类型。
```
___
# 面向对象
面向对象：把数据和对数据的操作方法放在一起，做成一个相互依靠的整体，称之为对象，对同类对象抽象出共同特性，类中大多数数据只能用本类的方法进行处理。
面向对象编程(OPP)的出现是为了更高效地组织和管理复杂代码，它通过封装、继承和多态三大特性，将数据和操作绑定为独立的对象，使程序更贴近现实世界的思维方式，从而提高代码的可重用性、可维护性和扩展性，同时降低大型软件系统的开发难度和维护成本。简单来说**OOP让代码更模块化、更安全、更易复用和扩展，适合构建复杂、长期维护的软件系统。**
那么面向对象的三大特性是如何对代码进行组织和管理的？
## 封装
将一类事物的属性和行为抽象为一个类，使其属性私有化，行为公开化，提高数据隐蔽性，复用性。
### 产生原因
封装可以防止外部代码直接访问和修改对象的内部数据，避免数据被意外破坏；隐藏类内的内部实现细节，只暴露出必要的接口，用户只需要如何使用类提供的接口，不需要了解内部的实现。类内部实现可以独立修改而不影响改类的代码，可以通过权限访问来确保数据的合法性和一致性。
### 原理
封装的本质是通过编译器的访问机制和内存布局规则，将数据与操作数据的方法绑定在一起，并对外隐藏内部实现细节。它的实现可以分为三个层面：
#### 1. 编译期的访问控制
C++通过`public`、`private`、`protected`关键字在**编译阶段**限制对类成员的访问：
- `public`成员：类的外部可以直接访问，类的内部和子类可以访问。
- `private`成员(默认)：类的外部不能直接访问，类的内部和子类可以访问。
- `protected`成员：类的外部不能直接访问，类的内部和子类可以访问，但是不能在类的外部直接访问。
#### 2. 对象的内存分布
  - 类的成员变量在内存中**按声明顺序连续存储**，与结构体(struct)相同。
  - **访问修饰符不影响内存布局**，`private`和`public`成员在内存中布局是相同的，只是通过访问修饰符来限制对成员的访问。
  - **成员函数**在底层被编译为普通函数，并隐式添加`this`指针，例如：
``` cpp
obj.setValue(10);  // 源码
Class_setValue(&obj, 10);  // 编译器转换后的调用
```
#### 3. 突破封装的底层操作
封装是**逻辑层面的约束**，而非物理隔离，因此可以通过以下方式绕过：
1. **指针偏移访问**：通过计算内存偏移直接读写私有成员。
2. **内存拷贝**：直接复制对象内存数据。
3. **友元机制**：允许特定外部函数或类访问私有成员。
### 使用场景
1. 信息隐藏：封装可以隐藏类的内部实现细节，使得用户只需要关注类的接口而不需要了解其内部实现，从而简化代码的使用和维护；
2. 数据保护：通过将数据私有化，封装可以保护数据免受意外修改或非法访问，提高了程序的安全性；
3. 接口统一：封装可以将一组相关的数据和方法组织在一起，形成一个独立的单元，使得用户可以通过统一的接口来操作这些数据和方法，提高了代码的可读性和可维护性。
4. 模块化设计：封装可以将代码分割成多个独立的模块，每个模块负责特定的功能，使得代码结构清晰，易于理解和扩展。

### 总结
封装的真正价值在于强制**高内聚、低耦合**的设计，而非物理隔离数据。它使代码更模块化，同时通过编译器降低认为错误的风险。

---
## 继承
进一步将属性和行为抽象成一个父类，而每个子类拥有父类的行为和属性，也有自己的行为和属性
### 产生原因
1. **代码复用**：允许在已有类的基础上创建新类，避免重复编写相同代码。
2. **层次化分类**：可以建立类的层次结构，反映现实世界的分类关系。
3. **扩展功能**：可以在不修改原有类的情况下扩展其功能。
### 原理
三种继承方式`public`、`protected`、`private`，基类`private`成员，经过任何继承都在派生类都不可见，基类`public`成员经过什么继承，就到派生域的什么作用域中，基类中的`protected`成员经过`public`继承还是到`protected`作用域中，经过`private`继承后到`private`作用域中。
在实际运行中一般是用的都是`public`继承，因为`protected`和`private`继承下来的成员都只只能在派生类的类里面使用，实际中扩展维护性不强。
### 使用场景
1. IS-A关系：当派生类确实是基类的一种特殊类型时；
2. 接口实现：抽象基类定义接口，派生类具体实现；
3. 代码复用：多个类有共同属性的时候提取基类；
### 扩展
#### 复用
##### 组合与继承
- `public`继承是一种is-a的关系，也就是说每个派生类**都是**一个基类的对象，相当于[人]与[学生]的关系。
- 组合相当于一种has-a的关系，假设B组合了A，每个B对象中**都有**一个A对象，相当于[人]与[手]的关系。
- **优先使用组合，而不是继承**，组合耦合度低，代码维护性好。
###### 白箱复用——继承
继承允许你根据基类的实现来定义派生类的实现，这种通过生成派生类的复用通常称之为**白箱复用**，术语“白箱”是相对可视性而言，在继承方式中，基类的内部细节对子类可见。继承一定程度的破坏了基类的封装，基类的改变对派生类有很大影响，派生类的基类之间的依赖关系很强，耦合度高。
例如以下示例代码：
``` cpp
class Animal {
public:
    void eat() { cout << "Animal eats" << endl; }
};

class Dog : public Animal {  // Dog 是 Animal（继承）
public:
    void bark() { cout << "Dog barks!" << endl; }
};
```
- `dog`是`animal`的一种，可以调用`eat()`方法。
###### 黑箱复用——组合
对象组合是继承之外的另一种复用选择。新的更复杂的功能可以通过组合对象来获得。**对象组合要求被组合对象之间具有良好定义的接口**。这种复用称之为**黑箱复用**，因为对象的内部细节是不可见的。对象只以“黑箱”形式出现，组合之间没有很强的依赖关系，**耦合度低**。优先使用组合对象有助于保持每个类被封装。
例如以下示例代码中：
```cpp
class Engine {
public:
    void start() { cout << "Engine started!" << endl; }
};

class Car {
private:
    Engine engine;  // Car 包含一个 Engine（组合）
public:
    void startCar() { engine.start(); }
};
```
- `car`拥有`engine`但是`engine`对`car`是不可见的，`car`只知道`engine`有`start`方法，但是不知道`engine`的内部实现。
- `car`与`engine`之间的耦合度低，`engine`的改变不会影响`car`的代码。
- `car`可以使用`engine`的方法，但是不能直接访问`engine`的成员变量。
#### static与继承
基类定义了static静态成员，则整个继承体系里面 只有一个 这样的成员——即无论派生出多少个子类，都只有一个static成员实例。
#### 菱形继承
一个派生类他有两个或两个以上的基类，这种行为称之为**多重继承**，在多重继承的基础上两个基类都继承自同一个基类，就会产生**二义性问题**，这种情况叫做菱形继承，还会产生**数据冗余**现象
可以用**虚继承**来解决菱形继承的二义性和数据冗余的问题，再继承关系前加上`virtual`关键字。
### 总结
继承是通过父子类关系实现代码复用（public、protected、private），优先用组合降低耦合，多重继承需注意菱形问题。
## 多态
### 产生原因
C++引入多态主要是为了增强代码的**灵活性、可扩展性**和**可维护性**。
#### 1. 实现接口统一，隐藏细节
通过基类定义统一接口派生类实现具体行为。用户只需要调用基类接口，无需关心底层细节。
示例：使用一个绘图方法绘制图形示，无需了解需要绘制的图形是用什么方法绘制的。
```cpp
class Shape{
public :
    virtual void draw() cosnt = 0; //统一接口
};
class Circle : public Shape{
    void draw() const override{
        //画圆具体细节
    }
};
```
#### 2. 动态绑定
通过虚函数和动态绑定，在运行时能根据对象类型决定调用的具体函数。
示例：
```cpp
Shape* shape = new Circle();
shape->draw();//实际调用Circle::draw()
```
#### 3. 增强代码的可扩展性
**开闭原则**：多态允许在不修改现有代码的情况下扩展功能。
新增派生类时基类接口无需改动，只需要实现新的派生类
示例：
```cpp
class Rectangle : public Shape{
    void draw() const override{
        //绘制矩形
    }
};
```
#### 4. 减少条件分支
用虚函数可以代替条件分支，使代码更加简洁。
反面示例：
```cpp
void drawShape(ShapeType type) {
    if (type == CIRCLE) { /* 画圆 */ }
    else if (type == SQUARE) { /* 画方形 */ }
    // ... 每新增一种类型需修改此处
}
```

#### 5. 实现设计模式
多态是许多设计模式的基础，例如：
- 工厂模式：通过基类返回不同的派生类对象。
- 策略模式：动态切换算法实现。
-  观察者模式：通知不同观察者时调用统一的接口。
### 原理
C++ 的多态通过**虚函数表（vtable）**和**动态绑定**实现：
每个包含虚函数的类会隐式生成一个虚函数表（存储虚函数地址），对象内部通过**虚指针（vptr）**指向该表。当通过基类指针或引用调用虚函数时，程序在运行时根据 vptr 找到实际对象的虚函数表，并调用正确的派生类函数，从而实现 **“运行时多态”**。
#### 虚函数工作原理
1. **虚函数表**：每个包含虚函数的类都有一个虚函数表，它是一直函数指针数组，存储瓜类所有虚函数的地址
2. **虚指针**：每个对象实例中包含一个隐藏的指针，指向该类的虚函数表
在编译阶段，编译器为每个包含虚函数的类创建一个虚函数表，类中插入一个隐藏的虚指针成员（通常是第一个成员），在构造函数中插入代码初始化这个虚指针

### 使用场景
#### 1. 统一接口，不同实现
多个类有相似的行为，但是具体的实现方法不同，就例如上面的绘制图形类。
#### 2. 运行时动态绑定
程序运行时才能确定调用哪个函数
例如游戏中的角色可能有不同的攻击方式：
```cpp
#include <iostream>
#include <string>

class Character {
public:
	virtual void attack() const { std::cout << "Basic attack!\n"; }
};

class Player : public Character{
public:
	void attack() const override { std::cout << "Player uses sword!\n"; }
};

class Enemy :public Character {
	void attack() const override { std::cout << "Enemy uses claws~\n"; }
};

void battle(const Character& c1, const Character& c2) {
	c1.attack();
	c2.attack();
}

int main() {
	Player p;
	Enemy e;
	battle(p, e);// 运行时决定调用 Player::attack() 或 Enemy::attack()
	return 0;
}
```
#### 3. 设计模式
多态是许多设计模式的基础，在后续设计模式章节中会讲解。
#### 4. 回调机制
事件处理、GUI编程中实现回调机制
### 扩展
#### 为什么析构函数通常被设置虚函数
当通过基类指针删除派生类对象时，如果基类析构函数不是虚函数，会导致派生类的析构函数不被调用，造成内存泄漏。
##### 具体机制
``` cpp
class Base{
public:
    ~Base(){
        std::cout << "Base destructor" << std::endl;
    }
};

class Derived : public Base{
public:
    ~Derived(){
        std::cout << "Derived destructor" << std::endl;
    }
};

Base* ptr = new Derived();
delete ptr; //只调用Base的析构函数
```
```cpp
class Base {
public:
    virtual ~Base() { cout << "Base destructor" << endl; }
    // 现在能正确调用派生类析构函数
};
```
##### 底层机制
- 当析构函数是虚函数时，`delete`操作符会通过vtable查找正确的析构函数调用
- 调用顺序：派生类析构->基类析构（编译器自动插入基类析构调用）
#### 动态绑定和静态绑定的区别，虚函数一定要是动态绑定吗？
**动态绑定和静态绑定的核心区别在于函数调用的解析时机**：静态绑定在编译器根据变量声明类型确定调用的函数版本，效率高但是不支持多态；动态绑定在运行时根据对象时机类型通过虚函数表查找调用，支持多态但是有额外的开销。
**虚函数调用不一定是动态绑定**：当通过对象实例直接调用或显示执行作用域时是静态绑定，只有通过基类指针/引用调用虚函数才会触发动态绑定。此外在构造函数/析构函数内部调用虚函数也属于静态绑定，因为此时对象类型已被固定。
